# Building a Minimal Linux Distribution from Scratch

This guide walks you through creating a basic, custom Linux distribution from the ground up. You can test the final product on a **real machine**, such as a Raspberry Pi, or use a **virtual environment**. For this tutorial, we will use QEMU to emulate an ARM development board (the Versatile PB) as our virtual machine.

---

## What is QEMU?

**QEMU**, which stands for "Quick Emulator," is a versatile and open-source machine emulator and virtualizer. Its primary function is to run an operating system designed for one hardware architecture (the "guest") on a machine with a completely different architecture (the "host"). QEMU achieves this by translating the guest's machine code into instructions that the host's processor can execute.

## Emulation vs. Virtualization

Although the terms are sometimes used interchangeably, there is a fundamental difference between emulation and virtualization:

- **Emulation:** This is the process of mimicking a hardware environment that is entirely different from the host machine. For example, running an ARM-based operating system on a computer with an x86 processor is emulation. The emulator (like QEMU in this mode) must translate every instruction from the guest architecture to the host architecture, which can result in slower performance compared to native execution.
- **Virtualization:** This technology allows multiple guest operating systems to run on the same physical hardware simultaneously, provided they are all compatible with the host's architecture (e.g., running Windows and Linux x86 guests on an x86 host machine). A program called a **Hypervisor** manages and allocates hardware resources directly to the guest systems, delivering performance that is very close to native hardware speed.

---

## Types of Virtualization

Virtualization technologies are primarily categorized into the following types:

1. **Full Virtualization:** The guest operating system is completely unaware that it is running in a virtual environment. The hypervisor emulates all necessary hardware, allowing unmodified operating systems to run.
2. **Hardware-Assisted Virtualization:** This is the most common approach today. Modern processors (e.g., those with Intel VT-x or AMD-V technology) include features that accelerate virtualization operations. This reduces the hypervisor's overhead and significantly improves performance. QEMU can leverage these features (via KVM on Linux) to achieve near-native performance.
3. **Paravirtualization:** This approach requires modifying the guest operating system's kernel to be aware that it is virtualized. This allows it to communicate directly with the hypervisor instead of making requests to emulated hardware, often resulting in better performance.
4. **Type 1 (Bare-Metal) Hypervisor:** This type of hypervisor runs directly on the host's hardware, acting as the primary controller. Guest operating systems then run on top of it. Examples include VMware ESXi and Microsoft Hyper-V.

---

## Building the Minimal Linux Distribution

_This guide is adapted from the following excellent resources:_

- [_Minimalistic Linux system on QEMU ARM_](https://lukaszgemborowski.github.io/articles/minimalistic-linux-system-on-qemu-arm.html "null")
- [_QEMU documentation for ARM Versatile PB board_](https://www.qemu.org/docs/master/system/arm/versatile.html "null")

### 1. Install QEMU for ARM

First, install the QEMU system emulator for the ARM architecture.

```bash
sudo apt update
sudo apt install qemu-system-arm
```

_**Note:** To explore all available options for the ARM system emulator, you can consult its manual page:_

```bash
man qemu-system-arm
```

### 2. Install Kernel Compilation Prerequisites

Next, install the tools and libraries required to compile the Linux kernel from source.

```bash
sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison
```

### 3. Install the ARM Cross-Compiler

To compile a kernel for the ARM architecture on a non-ARM machine (like an x86 PC), you need a cross-compiler.

```bash
sudo apt install gcc-arm-linux-gnueabi
sudo apt install g++-arm-linux-gnueabi 
```

#### Testing the Cross-Compiler

Let's verify that the cross-compiler is installed correctly by compiling a simple C program.

**a. Create a C source file:**

```bash
nvim hello.c
```

Paste the following code into the file:

```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    printf("Hello from QEMU on ARM VersatilePB!\n");
    // Loop forever to keep the process alive
    while(1) {
        sleep(1);
    }
    return 0;
}
```

**b. Compile natively (for your host machine):**

```bash
gcc hello.c -o hello_x86.out
file hello_x86.out
```

The output of the `file` command will show an executable for `x86-64`. You can run it directly with `./hello_x86.out`.

**c. Cross-compile for ARM:**

```bash
arm-linux-gnueabi-gcc --static hello.c -o hello_arm.out
file hello_arm.out
```

`EABIS` --> Embedded Application binary interface

Now, the `file` command will show an executable for the `ARM` architecture.

**d. Run the ARM executable with QEMU:** You cannot run the ARM binary natively on an x86 machine. We will use `qemu-user`, which allows running a single program compiled for a different architecture.

First, install `qemu-user` if you haven't already:

```bash
sudo apt install qemu-user
#to list all qemu-user that installed 
sudo dpkg -L qemu-user
```

Now, run the ARM binary using the QEMU user-mode emulator:

```bash
qemu-arm ./hello_arm.out
```

other solution without static compile

```bash
arm-linux-gnueabi-gcc --help
#list all library that install with this installed package
#when it installed, it installed minimal source source root which mean minimal file system that cross compiler nedded to compile and run user application
sudo dpkg -L arm-linux-gnueabi-gcc
#after --hlep you will find argument which -print-sysroot to print all library dir
arm-linux-gnueabi-gcc -print-sysroot
# it will print one of paths that use to search in it 
# to print all pathes
arm-linux-gnueabi-gcc -print-search-dirs
#it will print all dir
# to search in it 
arm-linux-gnueabi-gcc -print-search-dirs | tr ':' '\n' | xargs -I _ find _ -iname ld-linux.so.3
#this command search the dynamically library which needed to run arm compiled code with out statically linked
# the output will be like this --> /usr/lib/gcc-cross/arm-linux-gnueabi/13/../../../../arm-linux-gnueabi/lib/ld-linux.so.3
 qemu-arm -L /usr/arm-linux-gnueabi ./test
```

`tr` -> transalt this into onother thing. `xargs` save output in the input which name is _ and search in this _

You should see the "Hello from QEMU..." message printed to your terminal.

### 4. Download the Linux Kernel Source

Download the latest stable version of the Linux kernel source code from the official website.

- **Official Website:** [https://www.kernel.org/](https://www.kernel.org/ "null")

### 5. Extract the Kernel Source

Once downloaded, extract the archive. Replace `linux-X.Y.Z` with the version number you downloaded.

```bash
# For .tar.xz files, use the following command:
tar -xvf linux-X.Y.Z.tar.xz
cd linux-X.Y.Z
```

_Note: The `tar` flags `x` (e**x**tract), `v` (**v**erbose), and `f` (**f**ile) are used here._

### 6. Configure the Kernel

Before building the kernel, you need to configure it for our target hardware. This step ensures we build a minimal kernel to consume less memory.

```bash
# This command generates a default configuration for the Versatile PB board.
make O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatile_defconfig
```

- `O=./build/`: Specifies the output directory for the build artifacts.
- `ARCH=arm`: Sets the target architecture to ARM.
- `CROSS_COMPILE=arm-linux-gnueabi-`: Specifies the prefix for the cross-compilation toolchain.
- `versatile_defconfig`: Selects the default configuration file located at `arch/arm/configs/versatile_defconfig`.

You can also customize the kernel configuration using a menu-based interface:

```bash
make O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
```

### 7. Compile the Kernel

Now, compile the kernel using the configuration you just created.

```bash
time make -j$(nproc) O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
```

- `time`: Measures the total time taken for the compilation process.
- `-j$(nproc)`: Speeds up compilation by running multiple jobs in parallel, based on the number of available CPU cores.

### 8. Install Kernel Modules

Install the compiled kernel modules into a new directory that will serve as our root filesystem.

```bash
# Create a rootfs directory one level up from the kernel source
mkdir ../rootfs
# Install modules into the new rootfs directory
time make -j$(nproc) modules_install O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- INSTALL_MOD_PATH=../rootfs
```

- `INSTALL_MOD_PATH`: Specifies the destination directory for the kernel modules. The path is relative to the output build folder (`./build/`).

### 9. Boot the Kernel in QEMU

With the kernel compiled, you can now boot it in QEMU. A successful compilation produces the **Kernel Core** (`zImage`), **Kernel Modules**, and a **Device Tree Blob** (`.dtb`). The device tree is a data structure that describes the system's hardware to the kernel.

```bash
qemu-system-arm -M versatilepb -kernel build/arch/arm/boot/zImage -dtb build/arch/arm/boot/dts/arm/versatile-pb.dtb -serial stdio -append "serial=ttyAMA0"
```

- `-M versatilepb`: Specifies the target machine/board to emulate.
- `-kernel`: Provides the path to the compressed kernel image.
- `-dtb`: Provides the path to the device tree binary.
- `-serial stdio`: Redirects the guest's serial output to the host's standard I/O.
- `-append`: Passes boot arguments to the kernel.

The kernel will boot but will eventually panic because it cannot find a root filesystem or an `init` process to run.

### 10. Create an Initial Root Filesystem (initrd)

Now, let's create an initial RAM disk (`initrd`) containing a simple `init` program. We'll use the `hello_arm.out` binary from Step 3 as our init process.

```bash
# In the directory containing the 'rootfs' folder
cp hello_arm.out rootfs/init
```

Next, compress the `rootfs` directory into a `cpio` archive, which the kernel can load as an `initrd`.

```bash
cd rootfs/
find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../rootfs.cpio.gz
cd ..
```

- This command finds all files, pipes them to `cpio` to create an archive, and then compresses it with `gzip`.
- `-print0` to remove `\n` after print to print them in one line and the end is `\0` not `\n`

### 11. Run QEMU with the Kernel and initrd

An `initrd` is a temporary, RAM-based root filesystem used during the early boot process before the real root filesystem is mounted.

```bash
qemu-system-arm -M versatilepb \
-kernel ./linux-X.Y.Z/build/arch/arm/boot/zImage \
-dtb ./linux-X.Y.Z/build/arch/arm/boot/dts/arm/versatile-pb.dtb \
-initrd ./rootfs.cpio.gz \
-serial stdio \
-append "root=/dev/mem serial=ttyAMA0"
```

- `-initrd`: Specifies the path to the initial RAM disk.
- `-append "root=/dev/mem..."`: Tells the kernel that the root filesystem is in RAM.

### 12. Add a Minimal Shell with BusyBox

Our `init` process is just an infinite loop. To get a usable shell, we'll use **BusyBox**, which combines many common Unix utilities into a single, small executable.

**a. Download and Extract BusyBox:** Go to the [BusyBox website](https://busybox.net/ "null"), download the latest version, and extract it.

```bash
tar xvf busybox-1.36.1.tar.bz2
cd busybox-1.36.1
```

**b. Configure and Compile BusyBox:** We need to configure BusyBox to be compiled as a static binary. This includes all required libraries, so it has no external dependencies.

```bash
# Generate a default configuration
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- defconfig

# Open the menu to enable static linking
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
```

In the configuration menu, navigate to `Settings` -> `Build Options` and enable `Build static binary (no shared libs)`. Save and exit.

Now, compile and install BusyBox:

```bash
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j$(nproc)
# If you face build errors, try disabling networking features (like TC) via menuconfig.
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install
```

The compiled files will be placed in a directory named `_install/`.

**c. Copy BusyBox files to the rootfs:**

```bash
cd _install/
cp -r bin sbin usr ../../rootfs
cp -r linuxrc ../../rootfs
cd ../../
```

### 13. Create a Proper `init` Script

Now, let's create a real `init` script that will set up a minimal environment and start a shell.

**a. Create necessary directories and the script:**

```bash
cd rootfs
mkdir proc sys dev
rm init # Remove the old binary init
nvim init
```

**b. Add the following content to the `init` script:**

```bash
#!/bin/sh
echo -e "\nHello from the init process\n"

mount -tproc none /proc
mount -tsysfs none /sys
mknod -m660 /dev/mem c 1 1

exec /bin/sh
```

**c. Make the script executable and re-package the rootfs:**

```bash
chmod +x init
find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../rootfs.cpio.gz
cd ..
```

### 14. Finally, Run Your Simple Distribution!

You now have a kernel and a root filesystem with a working shell. Boot it with QEMU:

```bash
qemu-system-arm -M versatilepb \
-kernel ./linux-X.Y.Z/build/arch/arm/boot/zImage \
-dtb ./linux-X.Y.Z/build/arch/arm/boot/dts/arm/versatile-pb.dtb \
-initrd ./rootfs.cpio.gz \
-serial stdio \
-append "root=/dev/mem serial=ttyAMA0"
```

Congratulations! You should see your "Hello" message followed by a shell prompt (`/ #`). You have successfully built and booted your own minimal Linux distribution.

## Alternative: Using a Persistent Filesystem Image

The `initrd` method is great for testing, but it's temporary. To simulate a real device like an SD card, we can use a persistent disk image. This requires re-configuring the kernel to support block devices.

### 1. Create the Filesystem Image

First, we create a raw disk image file, format it with an `ext2` filesystem, and copy our `rootfs` contents into it.

```bash
# Create an empty 256MB disk image
dd if=/dev/zero of=rootfs.ext2 bs=1M count=256

# Format the image as ext2
mkfs.ext2 rootfs.ext2

# Mount the image to a temporary directory
mkdir temp_mount
sudo mount rootfs.ext2 temp_mount

# Copy the contents of our rootfs (built in step 10) into the image
sudo cp -r rootfs/* temp_mount/

# Unmount the image
sudo umount temp_mount
```

### 2. Re-configure the Kernel for Block Devices

Go back to your kernel source directory (`linux-X.Y.Z`) and run `menuconfig` to enable the necessary drivers.

```
make O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
```

Enable the following options (press `Y` for built-in `[*]` or `M` for module `<*>`).

- `Device Drivers --->`
    
    - `Generic Driver Options --->` (**optional**)
        
        - `[*] Maintain a devtmpfs filesystem to mount at /dev`
            
        - `[*] Automount devtmpfs at /dev, after the kernel mounted the rootfs`
            
    - `PCI support --->`
        
        - `[*] PCI controller drivers --->`
            
            - `[*] ARM Versatile PB PCI controller`
                
    - `SCSI device support --->`
        
        - `<*> SCSI device support`
            
        - `<*> SCSI disk support`
            
        - `[*] SCSI low-level drivers --->`
            
            - `[*] LSI Logic New Generation RAID Device Drivers`
                
            - `<*> SYM53C8XX Version 2 SCSI support`
                

Save your new configuration and exit.

### 3. Re-compile the Kernel

Since the configuration has changed, you must re-compile the kernel.

```
time make -j$(nproc) O=./build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
```

### 4. before build and avoid erro

```bash
sudo mount rootfs.ext2 temp_mount
mkdir -p temp_mount/etc/init.d/
sudo nvim temp_mount/etc/init.d/rcS
# and paste this code
#!/bin/sh
echo -e "\nHello From My Simple Distro\n"

mount -tproc none /proc
mount -tsysfs none /sys
mknod -m660 /dev/mem c 1 1

echo "Running /bin/Myshell..."
/bin/Myshell
ret=$?
echo "Myshell exited with code $ret"

echo "Falling back to /bin/sh..."
exec /bin/sh

# make it exautabel
sudo chmod +x temp_mount/etc/init.d/rcS
sudo umount temp_mount
```
### 4. Boot with the Persistent Filesystem Image

Now, run QEMU, telling it to use your `rootfs.ext2` image as a SCSI hard drive.

```bash
qemu-system-arm -M versatilepb -m 256M -serial stdio \
  -kernel linux-6.17/build/arch/arm/boot/zImage \
  -dtb linux-6.17/build/arch/arm/boot/dts/arm/versatile-pb.dtb \
  -append "console=ttyAMA0 root=/dev/sda rw rootwait" \
  -device lsi53c895a,id=scsi \
  -drive if=none,file=rootfs.ext2,format=raw,id=hd0 \
  -device scsi-hd,drive=hd0,bus=scsi.0
```

- `-append "root=/dev/sda ..."`: Tells the kernel the root device is the first SCSI disk (`sda`). `rootwait` tells it to wait for the device to be ready.
    
- `-device lsi53c895a`: Adds a virtual LSI SCSI controller.
    
- `-drive file=...`: Defines the disk image file.
    
- `-device scsi-hd...`: Attaches the drive to the SCSI controller.
    

Congratulations! You have now booted your custom Linux system from a persistent disk image.

## Method 3: Automating the Build with Buildroot

While building each component manually is a great learning experience, it can be time-consuming. **Buildroot** is a powerful tool that automates the entire process of building a complete embedded Linux system. It generates the cross-compilation toolchain, the root filesystem, the kernel image, and the bootloader for you.

### 1. Download and Extract Buildroot

First, download the latest version of Buildroot from the [official website](https://buildroot.org/download.html "null"). Then, extract the archive.

```
# Replace with the version you downloaded
tar xvf buildroot-2024.02.2.tar.gz
cd buildroot-2024.02.2
```

### 2. Configure Buildroot for QEMU ARM Versatile

Buildroot comes with many default configurations for common boards. We can use the one for our QEMU target.

```
# This sets up a complete configuration for the ARM Versatile PB board
make qemu_arm_versatile_defconfig
```

This command configures Buildroot to:

- Build a cross-compiler toolchain.
    
- Build a Linux kernel with the correct settings for Versatile PB.
    
- Build a root filesystem with BusyBox and other essential utilities.
    
- Create a persistent disk image (`rootfs.ext2`).
    

You can optionally run `make menuconfig` to customize the system further, such as adding more packages to the final image.

### 3. Build the System

Now, run the `make` command. Buildroot will automatically download all source code, compile it, and place the final images in the `output/images` directory.

```
# This process can take a long time, especially on the first run
make
```

### 4. Run the Buildroot-Generated System in QEMU

After the build is complete, you will find all the necessary files (`zImage`, `.dtb`, `rootfs.ext2`) in the `output/images` directory. You can run the system with a single command provided by Buildroot.

```
# Note: This command must be run from the Buildroot source directory
qemu-system-arm \
    -M versatilepb \
    -m 256M \
    -kernel output/images/zImage \
    -dtb output/images/versatile-pb.dtb \
    -drive file=output/images/rootfs.ext2,if=scsi,format=raw \
    -append "root=/dev/sda console=ttyAMA0,115200" \
    -serial stdio \
    -net nic,model=rtl8139 -net user
```

The system will boot, and the default login is `root` with no password. This method is much faster for creating a functional Linux system and is widely used in professional embedded systems development.


