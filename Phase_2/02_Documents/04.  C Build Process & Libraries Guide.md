# C Build Process & Libraries Guide

This guide explains the basic steps to convert source code from a `.c` file into an executable program, as well as how to create and use Static and Shared Libraries.

## First: The 4 Stages of the Build Process

The build process goes through four main stages, and we can use `gcc` (GNU Compiler Collection) to control each stage.

### 1. Preprocessing

**What happens?** The Preprocessor reads the `.c` source code and executes commands that start with a `#`.

- **`#include`**: This line is replaced with the content of the included file (e.g., `stdio.h`).
    
- **`#define`**: Every "macro" is replaced with its defined value.
    
- **Removing Comments**: All comments (`/* ... */` and `// ...`) are deleted.
    

**Output File**: A "Pure C Code" file with a `.i` extension.

**Command:**

```bash
# -E: Means "Stop after the preprocessing step only"
# -o source.i: Specify the output filename
gcc -E source.c -o source.i
```

### 2. Compilation

**What happens?** The Compiler takes the `.i` file (raw code) and converts it to Assembly Language specific to the target architecture (e.g., x86). This step also includes checking for syntax errors and performing optimizations.

**Output File**: An Assembly Language file with a `.s` extension.

**Command:**

```bash
# -S: Means "Stop after the compilation step only"
# (Uppercase S)
gcc -S source.i -o source.s
```

### 3. Assembly

**What happens?** The Assembler converts the assembly code (the `.s` file) into Machine Code, turning human-readable instructions (like `MOV`, `ADD`) into binary numbers that the processor understands.

**Output File**: An Object File with a `.o` extension. This file contains binary code but is not yet executable because it needs linking.

**Command:**

```bash
# -c: Means "Compile and assemble, but do not link"
# (Lowercase c)
gcc -c source.s -o source.o
```

### 4. Linking

**What happens?** This is the final stage. The Linker gathers your object file(s) (like `source.o`) along with any other libraries the program needs (like the `printf` function from the C standard library) to produce a complete executable file.

**Output File**: An Executable File. (e.g., `.exe` on Windows, or typically no extension on Linux/Mac).

**Command:**

```bash
# This is the default step if you don't specify -E, -S, or -c
# gcc calls the linker (ld) automatically
gcc source.o -o program.exe
```

## Creating a Map File

A map file is a text file that shows how the Linker organized functions and variables in memory within the executable. This is very useful for advanced debugging.

```bash
# -Wl,...: This flag passes the commands that follow it directly to the Linker (ld)
# -Map=main.map: We ask the linker to create a map file named main.map
gcc test.c -o test -Wl,-Map=main.map
```

## Second: Static Libraries

A static library is an "archive" (a file with a `.a` extension) that contains a collection of object files (`.o`). When you link your program against it, the code your program needs from the library is _copied_ into your final executable file. This makes the executable larger but self-contained.

### 1. Creating the Static Library

**Step A: Create Object Files** First, we need to convert all the `.c` files we want in the library into `.o` files.

```bash
# Use -c to create .o files only
gcc -c file1.c -o file1.o
gcc -c file2.c -o file2.o
# ... and so on

# Or compile all .c files in the current directory at once
gcc -c *.c
```

**Step B: Create the Archive (Library)** We use the `ar` (archiver) tool to create the library from the `.o` files.

```bash
# ar: The archiver tool
# r: Add files to the archive (or replace them if they already exist)
# c: Create the archive if it doesn't exist
# s: Create an index of the files inside the archive (important for linking speed)
# libfile.a: The library name. (It is conventional to start the name with "lib")

ar rcs libfile.a file1.o file2.o *.o
```

**Useful command:** To list the contents of the library (which `.o` files are inside):

```bash
ar t libfile.a
```

### 2. Using the Static Library (Linking with it)

Let's assume you have a program `main.c` that uses functions from your library `libfile.a`, which is located in a folder named `mylib`.

**Step A: Compile the Main Program** First, we create the `main.o` object file.

```bash
# -I./mylib: This tells the compiler to look in the "mylib" folder
# for header files (.h) that you #included in main.c
gcc -c main.c -o main.o -I./mylib
```

**Step B: Link the Program with the Library to Create the Executable**

```bash
# main.o: Your program's object file
# -L./mylib: This tells the Linker to look in the "mylib" folder
# for library files
# -lfile: This tells the Linker to look for a library named "libfile.a"
# (The linker automatically adds "lib" to the beginning and ".a" to the end of "file")

gcc main.o -o main_program -L./mylib -lfile
```

## Third: Shared (Dynamic) Libraries

A shared library (or "Shared Object" - `.so` file on Linux) is different. The code is **not** copied into your executable. Instead, the executable only contains a reference to the library. The operating system loads the shared library into memory **at runtime** when you run the program.

**Advantages:**

- **Smaller Executables:** Your program file is much smaller.
    
- **Efficiency:** If 10 programs use the same library, the OS only loads _one copy_ of the library into memory.
    
- **Updatability:** You can update the shared library (e.g., with bug fixes) without recompiling your main program.
    

### 1. Creating the Shared Library

**Step A: Create Position-Independent Object Files** When creating a shared library, you must compile your source files into **Position-Independent Code (PIC)**. This allows the library to be loaded at any memory address by the OS.

```bash
# -fPIC: Generate Position-Independent Code. This is mandatory for shared libraries.
# -c: Compile only, don't link.
gcc -c -fPIC file1.c -o file1.o
gcc -c -fPIC file2.c -o file2.o

# Or for all files:
gcc -c -fPIC *.c
```

**Step B: Create the Shared Library** Now, link these `.o` files together using the `-shared` flag.

```bash
# -shared: Tells gcc to create a shared library (.so file)
# *.o: All the PIC object files
gcc -shared -o libfile.so *.o
```

**Alternative (One-Step Method):** You can also combine these two steps into one:

```bash
gcc -fPIC -shared *.c -o libfile.so
```

### 2. Compiling with the Shared Library (Linking)

This step looks very similar to static linking. You tell the linker where to find the library and which one to use.

```bash
# -I./mylib: Tell the compiler where to find header files (.h)
# -L./mylib: Tell the linker where to find the library file (libfile.so)
# -lfile: Link against the library named "libfile.so"
# (The linker will prefer libfile.so over libfile.a if both exist)

gcc main.c -o main_program -I./mylib -L./mylib -lfile
```

At this point, `main_program` is created, but it only knows the _name_ `libfile.so`, not _where_ to find it at runtime.

### 3. Running the Program (Runtime Linking)

If you try to run `./main_program` directly, you will likely get an error: `./main_program: error while loading shared libraries: libfile.so: cannot open shared object file: No such file or directory`

This is because the OS loader (which runs your program) doesn't know to look in the `./mylib` folder. The `-L` flag was only for the _compiler/linker_ at _build time_.

You must tell the OS loader where to find your `.so` file using the `LD_LIBRARY_PATH` environment variable.

**Method 1: Set for a single command** Prefix the command with the variable. This is great for testing.

```bash
LD_LIBRARY_PATH=./mylib ./main_program
```

**Method 2: Set for the current terminal session** Use `export` to set the variable for your current shell.

```bash
export LD_LIBRARY_PATH=./mylib
./main_program
# You can now run ./main_program freely until you close this terminal
```

**Note on "Real" Installation:** For permanent installation, developers typically copy the `.so` file to a standard system directory (like `/usr/local/lib`) and then run `sudo ldconfig` to update the system's cache of known libraries.